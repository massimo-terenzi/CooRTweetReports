<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CooRTweetReports â€” Word Export</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body class="bg-gray-100 text-gray-900 font-sans leading-relaxed">
  <div class="max-w-5xl mx-auto p-6">
    <h1 class="text-3xl font-bold mb-2">CooRTweetReports</h1>
    <h2 class="text-xl font-medium text-gray-700 mb-4">GPT-based Narratives Analyzer</h2>
    <p class="text-sm text-gray-700 mb-6">
      Works with outputs from
      <a href="https://github.com/nicolarighetti/CooRTweet" target="_blank" class="text-blue-600 underline">CooRTweet</a>
      and
      <a href="https://github.com/massimo-terenzi/coortweetpost" target="_blank" class="text-blue-600 underline">CooRTweetPost</a>.
    </p>

    <!-- Inputs -->
    <div class="mb-4">
      <label class="block mb-1 font-medium">Upload <code>coordinated_communities.csv</code></label>
      <input type="file" id="communitiesFile" class="p-2 w-full border rounded" />
    </div>

    <div class="mb-4">
      <label class="block mb-1 font-medium">Upload <code>coordinated_objects_by_community.csv</code></label>
      <input type="file" id="objectsFile" class="p-2 w-full border rounded" />
    </div>

    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
      <div>
        <label class="block font-medium mb-1">Select % of top communities to analyze:</label>
        <input type="range" id="percentage" min="1" max="100" value="20" class="w-full">
        <div class="text-sm text-gray-600 mt-1"><span id="percentageValue">20</span>% selected</div>
      </div>
      <div>
        <label class="block font-medium mb-1">Max items per community (sample):</label>
        <input type="number" id="maxSample" min="10" max="500" value="100" class="p-2 w-full border rounded">
      </div>
      <div>
        <label class="block mb-1 font-medium">OpenAI API Key:</label>
        <input type="password" id="apiKey" placeholder="sk-..." class="p-2 w-full border rounded" />
        <p class="text-xs text-gray-500 mt-1">The key stays in your browser.</p>
      </div>
    </div>

    <div class="mb-2 flex flex-wrap items-center gap-3">
      <label class="inline-flex items-center gap-2 text-sm">
        <input type="checkbox" id="includeSummary" checked>
        Include Executive Summary in Word
      </label>
    </div>

    <!-- Actions -->
    <div class="mb-4 flex flex-wrap gap-2">
      <button id="btnRun" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Generate Reports</button>
      <button id="btnStop" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700">Stop</button>
      <button id="btnExportDoc" class="bg-purple-600 text-white px-4 py-2 rounded hover:bg-purple-700" disabled>Export Word (.doc)</button>
    </div>

    <!-- Progress -->
    <div id="progressWrap" class="mb-4 hidden">
      <div class="flex items-center justify-between mb-1">
        <span class="text-sm text-gray-700 font-medium">Progress</span>
        <span id="progressLabel" class="text-sm text-gray-600">0%</span>
      </div>
      <div class="w-full bg-gray-200 rounded h-3 overflow-hidden">
        <div id="progressBar" class="bg-blue-600 h-3 w-0 transition-all"></div>
      </div>
      <div id="progressCount" class="text-xs text-gray-600 mt-1">0/0</div>
    </div>

    <div id="preview" class="mb-6 text-sm text-gray-600"></div>
    <div id="output" class="mt-8 space-y-10"></div>
    <div id="status" class="mt-4 text-sm text-gray-600"></div>
  </div>

  <script>
    // ---------------- State ----------------
    let communities = [], objects = [];
    let stopFlag = false;
    const analyses = []; // { community, markdown, raw }

    // ---------------- UI bindings ----------------
    document.getElementById('percentage').addEventListener('input', (e) => {
      document.getElementById('percentageValue').textContent = e.target.value;
    });
    document.getElementById('btnRun').addEventListener('click', processData);
    document.getElementById('btnStop').addEventListener('click', () => stopFlag = true);
    document.getElementById('btnExportDoc').addEventListener('click', exportDOC);

    // ---------------- Pipeline ----------------
    function processData() {
      stopFlag = false;
      analyses.length = 0;
      document.getElementById('btnExportDoc').disabled = true;
      setStatus("");

      const communityFile = document.getElementById('communitiesFile').files[0];
      const objectFile = document.getElementById('objectsFile').files[0];
      const apiKey = document.getElementById('apiKey').value.trim();

      if (!communityFile || !objectFile) {
        alert("Please upload both CSV files.");
        return;
      }

      Papa.parse(communityFile, {
        header: true,
        dynamicTyping: true,
        complete: (res) => {
          communities = (res.data || []).filter(row =>
            row && row.community !== undefined && row.community !== null
          );
          Papa.parse(objectFile, {
            header: true,
            dynamicTyping: true,
            complete: (res2) => {
              objects = (res2.data || []).filter(row =>
                row && row.community !== undefined && row.community !== null
              ).map(row => ({
                community: String(row.community),
                object_id: String(row.object_id)
              }));
              analyzeTopCommunities(apiKey);
            }
          });
        }
      });
    }

    async function analyzeTopCommunities(apiKey) {
      try {
        const percent = parseInt(document.getElementById('percentage').value);
        const maxSample = parseInt(document.getElementById('maxSample').value) || 100;

        // sort by objects desc, then vertices
        communities.sort((a, b) => {
          const uoA = Number(a.unique_objects || 0), uoB = Number(b.unique_objects || 0);
          if (uoB === uoA) {
            const uvA = Number(a.unique_vertices || 0), uvB = Number(b.unique_vertices || 0);
            return uvB - uvA;
          }
          return uoB - uoA;
        });

        const selected = communities.slice(0, Math.ceil(communities.length * percent / 100));
        document.getElementById("preview").innerHTML =
          "<strong>Selected Communities:</strong><br>" +
          selected.map(c => `Community ${c.community} â€” Objects: ${c.unique_objects}, Vertices: ${c.unique_vertices}`).join("<br>");

        const output = document.getElementById('output');
        output.innerHTML = "";

        // Progress
        const total = selected.length;
        let done = 0;
        showProgress(done, total);

        for (const community of selected) {
          if (stopFlag) { updateProgress(++done, total); break; }

          const cid = String(community.community);
          const ids = objects.filter(o => o.community === cid).map(o => o.object_id).filter(Boolean);

          // sampling
          let used = ids.slice();
          if (used.length > maxSample) {
            used = shuffle(used).slice(0, maxSample);
          }

          // card
          const div = document.createElement("div");
          div.className = "bg-white p-4 rounded shadow border";
          div.innerHTML = `
            <h2 class="text-lg font-semibold mb-2">Community ${cid}</h2>
            <p class="mb-2 text-sm text-gray-600">Sample size: ${used.length} of ${ids.length}</p>
            <div class="mt-2 text-sm font-mono text-gray-500" id="result-${cid}">Analyzing <span class="animate-pulse">...</span></div>
          `;
          output.appendChild(div);

          // call API
          let analysis = "ðŸ”’ API key not provided.";
          if (apiKey) {
            const prompt = generatePrompt(used);
            analysis = await callOpenAI(apiKey, prompt) || "âŒ No response or error.";
          }

          document.getElementById(`result-${cid}`).textContent = analysis;

          // store for export (prepend heading)
          const header = `## Community ${cid}`;
          const mdBlock = `${header}\n\n${analysis}`;
          analyses.push({ community: cid, markdown: mdBlock, raw: analysis });

          // abilita export appena c'Ã¨ il primo risultato
          if (analyses.length === 1) {
            document.getElementById('btnExportDoc').disabled = false;
          }

          updateProgress(++done, total);
          await sleep(400);
          if (stopFlag) break;
        }

        if (!stopFlag && analyses.length > 0) {
          document.getElementById('btnExportDoc').disabled = false;
          setStatus("âœ… Analyses complete. You can now Export Word.");
        } else if (stopFlag && analyses.length > 0) {
          document.getElementById('btnExportDoc').disabled = false;
          setStatus("â¹ Stopped. You can export partial results.");
        } else {
          setStatus("No results to export.");
        }
      } catch (err) {
        console.error(err);
        alert("An error occurred during analysis. Open the browser console for details.");
      }
    }

    // ---------------- Prompts & API ----------------
    function generatePrompt(texts) {
      return `### ChatGPT analysis ###\n\n` +
        `You are an AI assistant helping users analyze clusters of short text messages or social media posts that were likely distributed in a coordinated way. The goal is to identify patterns in language, tone, or rhetorical framing that may reveal shared objectives, ideological leanings, or manipulative strategies.\n\n` +
        `Here is a list of shared texts (IDs or short texts):\n` +
        texts.map(t => `- ${t}`).join("\n") +
        `\n\nGroup the texts by themes or narratives. Describe rhetorical strategies. Include examples (original with English translation if needed). Conclude with a summary.\n\n### ChatGPT analysis ###`;
    }

    async function callOpenAI(apiKey, prompt) {
      try {
        const res = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "user", content: prompt }],
            temperature: 0.3
          })
        });
        const json = await res.json();
        if (json.error) {
          console.error("OpenAI error:", json.error);
          return `âš ï¸ OpenAI error: ${json.error.message || "unknown"}`;
        }
        return json.choices?.[0]?.message?.content?.trim();
      } catch (err) {
        console.error(err);
        return "âš ï¸ Error during API request.";
      }
    }

    async function callOpenAIChat(apiKey, systemPrompt, userPrompt, model = "gpt-4o-mini", temperature = 0.3) {
      const res = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": "Bearer " + apiKey
        },
        body: JSON.stringify({
          model, temperature,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user",   content: userPrompt }
          ]
        })
      });
      const json = await res.json();
      if (json.error) {
        console.error("OpenAI error:", json.error);
        return `âš ï¸ OpenAI error: ${json.error.message || "unknown"}`;
      }
      return json.choices?.[0]?.message?.content?.trim();
    }

    // ---------------- Export Word (.doc) ----------------
    function fixMojibake(s) {
      if (!s) return s;
      return s
        .replace(/ÃƒÂ¢/g,"Ã¢").replace(/Ãƒâ€š/g,"Ã‚")
        .replace(/ÃƒÂ®/g,"Ã®").replace(/ÃƒÅ½/g,"ÃŽ")
        .replace(/Ã„Æ’/g,"Äƒ").replace(/Ä‚/g,"Ä‚")
        .replace(/Ãˆâ„¢/g,"È™").replace(/ÃˆËœ/g,"È˜")
        .replace(/Ãˆâ€º/g,"È›").replace(/ÃˆÅ¡/g,"Èš")
        .replace(/Ã…Å¸/g,"È™").replace(/Ã…Å¾/g,"È˜")
        .replace(/Ã…Â£/g,"È›").replace(/Ã…Â¢/g,"Èš")
        .replace(/ÃƒÂ¡/g,"Ã¡").replace(/ÃƒÂ©/g,"Ã©").replace(/ÃƒÂ­/g,"Ã­")
        .replace(/ÃƒÂ³/g,"Ã³").replace(/ÃƒÂº/g,"Ãº").replace(/ÃƒÂ±/g,"Ã±")
        .replace(/ÃƒÂ¨/g,"Ã¨").replace(/ÃƒÂ¹/g,"Ã¹").replace(/ÃƒÂ¬/g,"Ã¬")
        .replace(/ÃƒÂª/g,"Ãª").replace(/ÃƒÂ«/g,"Ã«").replace(/ÃƒÂ¼/g,"Ã¼")
        .replace(/ÃƒÂ¶/g,"Ã¶").replace(/ÃƒÂ¤/g,"Ã¤").replace(/ÃƒÅ“/g,"Ãœ")
        .replace(/Ãƒâ€“/g,"Ã–").replace(/Ãƒâ€ž/g,"Ã„")
        .replace(/Ã¢â‚¬â€œ/g,"â€“").replace(/Ã¢â‚¬â€/g,"â€”")
        .replace(/Ã¢â‚¬Å“/g,"â€œ").replace(/Ã¢â‚¬Â/g,"â€")
        .replace(/Ã¢â‚¬Ëœ/g,"â€˜").replace(/Ã¢â‚¬â„¢/g,"â€™")
        .replace(/Ã‚Â«/g,"Â«").replace(/Ã‚Â»/g,"Â»")
        .replace(/Ã‚ /g," ");
    }

    function mdToHtml(md) {
      md = fixMojibake(md || "");
      md = md.replace(/\r\n/g,"\n");

      // code fences
      md = md.replace(/```([\s\S]*?)```/g, (_,code) =>
        `<pre><code>${escapeHtml(code)}</code></pre>`);

      // inline code
      md = md.replace(/`([^`]+)`/g, (_,code) => `<code>${escapeHtml(code)}</code>`);

      // bold / italic
      md = md.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
      md = md.replace(/(^|[^_])_([^_]+)_(?!_)/g, "$1<em>$2</em>");
      md = md.replace(/(^|[^*])\*([^*]+)\*(?!\*)/g, "$1<em>$2</em>");

      // headings
      md = md.replace(/^######\s+(.*)$/gm, "<h6>$1</h6>");
      md = md.replace(/^#####\s+(.*)$/gm,  "<h5>$1</h5>");
      md = md.replace(/^####\s+(.*)$/gm,   "<h4>$1</h4>");
      md = md.replace(/^###\s+(.*)$/gm,    "<h3>$1</h3>");
      md = md.replace(/^##\s+(.*)$/gm,     "<h2>$1</h2>");
      md = md.replace(/^#\s+(.*)$/gm,      "<h1>$1</h1>");

      // bullets: -, *, â€¢, ". "
      md = md.replace(/^(?:-|\*|â€¢|\.)\s+(.*)$/gm, "<li>$1</li>");
      md = md.replace(/(?:\s*<li>[\s\S]*?<\/li>\s*)+/g, m => `<ul>${m}</ul>`);

      // horizontal rule
      md = md.replace(/^-----+$|^---+$/gm, "<hr/>");

      // pagebreak marker
      md = md.replace(/^(\\pagebreak|\f)$/gm, '<div style="page-break-after:always;"></div>');

      // paragraphs
      md = md.split("\n").map(line => {
        if (!line.trim()) return "";
        if (/^<(h\d|ul|li|pre|code|hr|div|p)/i.test(line)) return line;
        return `<p>${line}</p>`;
      }).join("\n");

      return md;
    }

    function escapeHtml(s){
      return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    async function exportDOC() {
      if (analyses.length === 0) { alert("No analyses available."); return; }

      const btn = document.getElementById('btnExportDoc');
      const prev = btn.textContent;
      btn.textContent = "Exportingâ€¦";
      btn.disabled = true;
      setStatus("â³ Preparing Word documentâ€¦");

      try {
        // order by community
        const ordered = analyses.slice().sort((a,b)=>{
          const na=Number(a.community), nb=Number(b.community);
          return (!isNaN(na)&&!isNaN(nb)) ? na-nb : String(a.community).localeCompare(String(b.community));
        });

        const combined = ordered.map(a => a.markdown).join("\n\n-----\n\n");

        const includeSummary = document.getElementById('includeSummary')?.checked;
        let summary = "*No summary available (no API key provided).*";
        if (includeSummary) {
          const apiKey = document.getElementById('apiKey').value.trim();
          if (apiKey) {
            const summarySys = "You produce concise, factual executive summaries.";
            const summaryUser = [
              "Produce an 8â€“12 bullet-point executive summary capturing main entities, dominant narratives, ideological framings, and notable rhetorical patterns.",
              "Be neutral and formal. Do NOT repeat evidence; synthesize.",
              "End with 2â€“3 risks/implications.",
              "Input delimited by <CORPUS> tags.",
              "<CORPUS>",
              combined,
              "</CORPUS>"
            ].join("\n");
            const raw = await callOpenAIChat(apiKey, summarySys, summaryUser, "gpt-4o-mini", 0.2);
            if (raw) summary = raw;
          }
        }

        // Word-compatible HTML
        const html = `
<!DOCTYPE html>
<html><head>
<meta charset="UTF-8">
<title>CooRTweet Report</title>
<style>
  body { font-family: Helvetica, Arial, sans-serif; line-height:1.35; }
  h1 { font-size: 24pt; margin: 12pt 0 6pt; }
  h2 { font-size: 18pt; margin: 10pt 0 6pt; }
  h3 { font-size: 16pt; margin: 8pt 0 4pt; }
  ul { margin: 0 0 8pt 18pt; }
  p  { margin: 0 0 8pt; }
  hr { border: none; border-top: 1pt solid #999; margin: 12pt 0; }
  .pagebreak { page-break-after: always; }
  code, pre { font-family: "Courier New", monospace; }
</style>
</head><body>
  ${mdToHtml("# Coordinated Communities â€” Narrative Analysis")}
  ${includeSummary ? mdToHtml("## Executive Summary\n\n" + summary) : ""}
  ${includeSummary ? '<div class="pagebreak"></div>' : ""}
  ${mdToHtml("# Full Analysis\n\n" + combined)}
</body></html>`.trim();

        setStatus("ðŸ“¦ Building fileâ€¦");
        downloadDOC("narrative_report_full.doc", html);
        setStatus("ðŸ“„ Download started: narrative_report_full.doc");
      } catch (e) {
        console.error(e);
        alert("Export failed. See console.");
        setStatus("âŒ Export failed.");
      } finally {
        setTimeout(()=>{ btn.textContent = prev; btn.disabled = false; }, 600);
      }
    }

    function downloadDOC(filename, html){
      const blob = new Blob([html], { type: "application/msword;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
    }

    // ---------------- UX utils ----------------
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    function shuffle(a){ return a.map(v=>[Math.random(),v]).sort((x,y)=>x[0]-y[0]).map(x=>x[1]); }

    function showProgress(done, total){
      const wrap = document.getElementById('progressWrap');
      const bar  = document.getElementById('progressBar');
      const lab  = document.getElementById('progressLabel');
      const cnt  = document.getElementById('progressCount');
      wrap.classList.remove('hidden');
      const pct = total ? Math.round((done/total)*100) : 0;
      bar.style.width = pct + "%";
      lab.textContent = pct + "%";
      cnt.textContent = `${done}/${total}`;
    }
    function updateProgress(done, total){ showProgress(done, total); }
    function setStatus(msg){ document.getElementById('status').textContent = msg; }
  </script>
</body>
</html>
